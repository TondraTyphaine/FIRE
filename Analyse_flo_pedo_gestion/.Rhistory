library(tidyverse)
data <- read_csv2("Data_flo_pedo_gestion.csv")
data
library(tidyverse)
data <- read_csv2("Data_flo_pedo_gestion.csv")
data
library(ade4)
library(psych)
# Draftsman plot et heatmap pour étudier les variables et leurs relations
## Epaisseur et nombre d'horizon
data %>%
select(Mean_horizon_nb, mean_O_thickness,mean_A_thickness, mean_T1_thickness,mean_T2_thickness, mean_J_thickness,mean_T3_thickness, Sand_pourcentage, Loam_pourcentage, Clay_pourcentage)->
data_1
pairs.panels(data_1,
method = "pearson", # correlation method
hist.col = "#00AFBB",
density = TRUE,  # show density plots
ellipses = FALSE # show correlation ellipses
)
## Pourcentages des types biologiques
data %>%
select(Therophyte_pourcentage, Geophyte_pourcentage, Hemicroptophyte_pourcentage, Chamephyte_pourcentage, lianescent_pourcentage, Phanerophyte_pourcentage, Helophyte_pourcentage)->
data_2
pairs.panels(data_2,
method = "pearson", # correlation method
hist.col = "#00AFBB",
density = TRUE,  # show density plots
ellipses = FALSE # show correlation ellipses
)
## Epaisseur et nombre d'horizon et pourcentages des types biologiques
data %>%
select(-Sample,-Panels, -Late_mowing,-Dead_wood, -Cut, -Plantation, -Elagage, -ZNIEFF, -Leisure_facilities)->
data_3
cor_matrix <- cor(data_3, use = "complete.obs", method = "pearson")
library(ggplot2)
library(reshape2)  # Pour "melt" la matrice en format long
# Convertir la matrice de corrélation en format long
cor_melted <- melt(cor_matrix)
# Créer la heatmap avec ggplot2
ggplot(cor_melted, aes(Var1, Var2, fill = value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "Heatmap de la matrice de corrélation")
## Variables de gestion
data %>%
select(Panels, Late_mowing,Dead_wood, Cut, Plantation, Elagage, ZNIEFF, Leisure_facilities) ->
data_4
# # Initialiser une matrice vide pour les résultats de corrélation
# cor_matrix_phi <- matrix(ncol = ncol(data_4), nrow = ncol(data_4))
#
# # Remplir la matrice avec les coefficients Phi pour chaque paire de variables
# for (i in 1:(ncol(data_4) - 1)) {  # Première boucle pour les indices de colonnes
#   for (j in (i + 1):ncol(data_4)) {  # Deuxième boucle pour les paires (i, j) où j > i
#     # Utiliser drop = TRUE pour obtenir un vecteur
#     cor_matrix_phi[i, j] <- phi(data_4[, i, drop = TRUE], data_4[, j, drop = TRUE])  # Calcul de la corrélation Phi
#     cor_matrix_phi[j, i] <- cor_matrix_phi[i, j]  # Matrice symétrique : valeur à [j, i] égale à [i, j]
#   }
# }
#
# library(ggplot2)
# library(reshape2)
#
# # Transformer la matrice de corrélation en format long
# cor_matrix_long <- melt(cor_matrix_phi)
#
# # Créer la heatmap avec ggplot2
# ggplot(cor_matrix_long, aes(Var1, Var2, fill = value)) +
#   geom_tile() +
#   geom_text(aes(label = round(value, 2)), color = "white") +
#   scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0) +
#   theme_minimal() +
#   labs(title = "Matrice de corrélation Phi entre variables binaires",
#        x = "Variables", y = "Variables")
# Standardiser les variables quantitatives (seulement pour les variables quantitatives)
data_quantitative_scaled <- scale(data_3)  # Mise à l'échelle
# Concaténer les données binaires et quantitatives standardisées
data_scaled <- cbind(data_quantitative_scaled, data_4)
# Effectuer l'ACP
library(FactoMineR)
acp <- PCA(data_scaled, ncp = 4, scale. = TRUE)
# Les axes
## Histogramme des valeurs propres
barplot(acp$eig[,1], main="valeurs propres", names.arg=paste("dim", 1:nrow(acp$eig)))
## Contribution des axes (composantes principales)
contribution_axes <- acp$eig
contribution_axes
## Graphique de la variance expliquée par chaque axe
barplot(contribution_axes[, 2], names.arg = 1:nrow(contribution_axes),
main = "Contributions des axes (Variance expliquée)",
xlab = "Axe", ylab = "Variance expliquée (%)",
col = "lightblue")
# Les variables
## Coordonnées variables
acp$svd$V
## Cercles des corrélations
plot.PCA (acp, choix="var", invisible="ind.sup")
## Matrice des corrélations entre les variables et les axes
acp$var$cor
## Contribution des variables aux axes
contribution_variables <- acp$var$contrib
head(contribution_variables)  # Afficher les premières lignes pour voir la structure
## Heatmap des contributions des variables
install.packages("pheatmap")
library(pheatmap)
pheatmap(contribution_variables, main = "Heatmap des contributions des variables",
cluster_rows = TRUE, cluster_cols = TRUE, color = colorRampPalette(c("white", "blue"))(50))
## Visualiser la qualité de la représentation des variables avec Cos2
cos2_var <- acp$var$cos2
fviz_cos2(acp, choice = "var", axes = 1:2) +
ggtitle("Qualité de la représentation des variables (Cos2)")  # Ajouter un titre via ggtitle
## Visualiser la qualité de la représentation des variables avec Cos2
library(factoextra)
cos2_var <- acp$var$cos2
fviz_cos2(acp, choice = "var", axes = 1:2) +
ggtitle("Qualité de la représentation des variables (Cos2)")  # Ajouter un titre via ggtitle
# Standardiser les variables quantitatives (seulement pour les variables quantitatives)
data_quantitative_scaled <- scale(data_3)  # Mise à l'échelle
# Concaténer les données binaires et quantitatives standardisées
data_scaled <- cbind(data_quantitative_scaled, data_4)
# Effectuer l'ACP
library(FactoMineR)
acp <- PCA(data_scaled, ncp = 4, scale. = TRUE)
# Les axes
## Histogramme des valeurs propres
barplot(acp$eig[,1], main="valeurs propres", names.arg=paste("dim", 1:nrow(acp$eig)))
## Contribution des axes (composantes principales)
contribution_axes <- acp$eig
contribution_axes
## Graphique de la variance expliquée par chaque axe
barplot(contribution_axes[, 2], names.arg = 1:nrow(contribution_axes),
main = "Contributions des axes (Variance expliquée)",
xlab = "Axe", ylab = "Variance expliquée (%)",
col = "lightblue")
# Les variables
## Coordonnées variables
acp$svd$V
## Cercles des corrélations
plot.PCA (acp, choix="var", invisible="ind.sup")
## Matrice des corrélations entre les variables et les axes
acp$var$cor
## Contribution des variables aux axes
contribution_variables <- acp$var$contrib
head(contribution_variables)  # Afficher les premières lignes pour voir la structure
## Heatmap des contributions des variables
install.packages("pheatmap")
library(pheatmap)
pheatmap(contribution_variables, main = "Heatmap des contributions des variables",
cluster_rows = TRUE, cluster_cols = TRUE, color = colorRampPalette(c("white", "blue"))(50))
## Visualiser la qualité de la représentation des variables avec Cos2
library(factoextra)
cos2_var <- acp$var$cos2
fviz_cos2(acp, choice = "var", axes = 1:2) +
ggtitle("Qualité de la représentation des variables (Cos2)")  # Ajouter un titre via ggtitle
# Les individus
## Coordonnées
acp$svd$U
## Représentation
plot.PCA (acp, choix="ind", invisible="ind.sup")
## Contribution des individus à chaque axe
contribution_individus <- acp$ind$contrib
head(contribution_individus)  # Afficher les premières lignes pour voir la structure
## Graphique des individus avec la contribution à l'axe 1
plot(acp, choix = "ind", main = "Graphique des individus (ACP)")
## Visualiser les individus avec la qualité de la représentation sur les axes principaux
install.packages("factoextra")
library(factoextra)
fviz_pca_ind(acp, col.ind = "cos2", gradient.cols = c("white", "blue"),
title = "Représentation des individus (qualité)")
install.packages("pheatmap")
## Qualité de la représentation des variables par les axes
cos2_individus <- acp$ind$cos2
## Heatmap des cosinus des angles (qualité de la représentation)
pheatmap(cos2_individus, main = "Heatmap de la qualité de la représentation des individus",
cluster_rows = TRUE, cluster_cols = TRUE, color = colorRampPalette(c("white", "blue"))(50))
# Visualiser l'ACP avec les noms des points issus de la colonne "ID"
install.packages("factoextra")
fviz_pca_ind(acp,
label = data$Sample,  # Utiliser la colonne "Samples" pour les labels
geom.ind = "point",     # Points pour les individus
col.ind = "blue",        # Couleur des points
labelsize = 3,           # Taille des labels
repel = F,            # Eviter les chevauchements
title = "Visualisation of all samples")
data
## Matrice des corrélations entre les variables et les axes
acp$var$cor
## Cercles des corrélations
plot.PCA (acp, choix="var", invisible="ind.sup")
acp <- PCA(data_scaled, ncp = 4, scale. = TRUE)
